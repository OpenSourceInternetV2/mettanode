/*
 * Simple hash table management and lookup.
 * Hash collisions are resolved by bumping through the table
 * rather than by keeping a list of objects at each entry.
 * We try to keep the hash table at most 1/2 full,
 * and always keep it at most 3/4 full.
 * Hash collisions are never generated by randomly selected port numbers -
 * if a collision would be generated, we pick a new port and try again.
 * The only ways hash collisions can be generated
 * are by explicitly bound port numbers and by hash table downsizing.
 */

#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include <errno.h>

#include "hash.h"


#define min(a,b)	((a) < (b) ? (a) : (b))
#define max(a,b)	((a) > (b) ? (a) : (b))


/* Minimum hash table size */
#define MINLEN 16


HashTab::HashTab()
{
	ht = NULL;
	htlen = 0;
	nents = 0;

	resize(MINLEN);
}

HashTab::~HashTab()
{
	if (ht != NULL)
		delete [] ht;
	ht = NULL;
}

size_t HashTab::hashfunc(const void *key, size_t keylen)
{
	const uint8_t *p = (const uint8_t*)key;
	size_t prehash = 0, hash = 0;

	while (keylen > 0) {
		// prehash = (prehash * 127) + *p++
		prehash = (prehash << 7) - prehash + *p++;
		hash += prehash;
		keylen--;
	}

	return hash;
}

/* Lookup the entry for a given key, if any */
struct HashEnt *HashTab::lookup(const void *key, size_t keylen)
{
	assert(ht != NULL);

	size_t hash = hashfunc(key, keylen);

	struct HashEnt *e;
	for (size_t i = hash & htmask; (e = ht[i]) != NULL;
		i = (i+1) & htmask)
	{
		if (e->hash == hash && e->keylen == keylen &&
			memcmp(e->key, key, keylen) == 0)
			return e;
	}

	return NULL;
}

/*
 * Resize the hash table of port descriptors,
 * or initialize it if one doesn't already exist.
 */
void HashTab::resize(size_t newlen)
{
	HashEnt **oldht = ht;

	size_t newmask = newlen-1;
	assert(newlen > 0);
	assert((newlen & newmask) == 0);
	assert(newlen >= nents*2);

	HashEnt **newht = new HashEnt*[newlen];
	memset(newht, 0, newlen*sizeof(HashEnt*));

	for (size_t i = 0; i < htlen; i++) {
		struct HashEnt *e = oldht[i];
		if (e == NULL)
			continue;

		size_t j;
		for (j = e->hash & newmask; newht[j] != NULL;
			j = (j+1) & newmask) {
		}
		newht[j] = e;
	}

	ht = newht;
	htlen = newlen;
	htmask = newmask;

	if (oldht != 0)
		delete [] oldht;
}

/* Check to see if insertion of a particular key
 * would cause a hash collision. */
int HashTab::collides(const void *key, size_t keylen)
{
	int hash = hashfunc(key, keylen);
	return ht[hash & htmask] != NULL;
}

/*
 * Insert an entry into the hash table.
 */
void HashTab::insert(struct HashEnt *e, const void *key, size_t keylen)
{
	assert(e->key == NULL);

	/* Try to grow the hash table whenever it becomes half full,
	 * but don't necessarily fail the insert if the grow fails. */
	if (nents >= htlen/2) {
		try {
			resize(htlen*2);
		} catch (...) {

			/* If the hash table is already _really_ full
			 * and we still can't grow it, then fail. */
			if (nents >= htlen*3/4)
				throw;
		}
	}

	size_t hash = hashfunc(key, keylen);

	HashEnt *ee;
	size_t i;
	for (i = hash & htmask; (ee = ht[i]) != NULL; i = (i+1) & htmask) {
		HashEnt *ee = ht[i];

		/* Make sure the key doesn't already exist */
		if (ee->hash == hash && ee->keylen == keylen &&
			memcmp(ee->key, key, keylen) == 0)
			throw EADDRINUSE;
	}

	/* Insert the entry */
	e->hash = hash;
	e->key = key;
	e->keylen = keylen;
	ht[i] = e;
	nents++;
}

/*
 * Remove an entry from the hash table.
 */
void HashTab::remove(struct HashEnt *e)
{
	if (e->key == NULL)
		throw EINVAL;

	//assert(e->hash == hashfunc(e->key, e->keylen));

	/* Find and zero the appropriate hash table entry */
	int i;
	for (i = e->hash & htmask; ht[i] != e; i = (i+1) & htmask) {
		if (ht[i] == NULL)
			throw EINVAL;
	}
	e->key = NULL;
	ht[i] = 0;
	nents--;

	/* Reinsert any immediately following entries to fill the hole */
	i = (i+1) & htmask;
	while (ht[i] != NULL) {
		struct HashEnt *e2 = ht[i];
		ht[i] = NULL;

		int j;
		for (j = e2->hash & htmask; ht[j] != 0; j = (j+1) & htmask) {
		}
		ht[j] = e2;
	}

	/* Shrink the hash table if it gets too sparse */
	if (nents < htlen/8 && htlen > MINLEN) {
		int newlen = htlen/4;
		if (newlen < MINLEN)
			newlen = MINLEN;
		try {
			resize(newlen);
		} catch (...) { }
	}
}

void HashTab::clear(int del)
{
	unsigned cnt = 0;
	for (size_t i = 0; i < htlen; i++) {
		HashEnt *e = ht[i];
		if (e != NULL) {
			if (del)
				delete e;
			ht[i] = NULL;
			cnt++;
		}
	}
	assert(cnt == nents);
	nents = 0;

	resize(MINLEN);
}

